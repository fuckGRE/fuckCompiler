// #@@range/options{
options {
    STATIC = false; //生成的都是非static的
    DEBUG_PARSER = true;    //启用javaCC的跟踪功能
    UNICODE_INPUT = true;   //为了支持中文
    JDK_VERSION = "1.5";
}
// #@@}

PARSER_BEGIN(Parser)
package net.loveruby.cflat.parser;
import net.loveruby.cflat.ast.*;
import net.loveruby.cflat.entity.*;
import net.loveruby.cflat.type.*;
import net.loveruby.cflat.asm.Label;
import net.loveruby.cflat.utils.ErrorHandler;
import net.loveruby.cflat.exception.*;
import java.lang.reflect.*;
import java.util.*;
import java.io.*;

//生成从文件读入代码的解析器
public class Parser {

    static public AST parseFile(File file,
                                ErrorHandler errorHandler)
                                throws SyntaxException, FileException {
        return parseFile(file,  errorHandler, false);
    }

    // #@@range/parseFile{
    //解析文件的静态方法
    static public AST parseFile(File file,
                                ErrorHandler errorHandler, boolean debug)
                                throws SyntaxException, FileException {
    // 首先用newFileParser生成从文件读入代码的解析器，并调用parse方法开始解析
        return newFileParser(file, errorHandler, debug).parse();
    }
    // #@@}

    static public Declarations parseDeclFile(File file,

                                             ErrorHandler errorHandler)
                                             throws SyntaxException,
                                                    FileException {
        return parseDeclFile(file, errorHandler, false);
    }

    static public Declarations parseDeclFile(File file,

                                             ErrorHandler errorHandler,
                                             boolean debug)
                                             throws SyntaxException,
                                                    FileException {
        return newFileParser(file,  errorHandler, debug).parseDecls();
    }

    // #@@range/newFileParser{
    // 生成读取文件file的FileInputStream对象，并用InputStreamReader和BufferedReader将其封装
    static final public String SOURCE_ENCODING = "UTF-8";

    static public Parser newFileParser(File file,

                                       ErrorHandler errorHandler,
                                       boolean debug)
                                       throws FileException {
        try {
            BufferedReader r =
                new BufferedReader(
                    new InputStreamReader(new FileInputStream(file),
                                          SOURCE_ENCODING));
            return new Parser(r, file.getPath(),  errorHandler, debug);
        }
        catch (FileNotFoundException ex) {
            throw new FileException(ex.getMessage());
        }
        catch (UnsupportedEncodingException ex) {
            throw new Error("是否不支持UTF-8? " + ex.getMessage());
        }
    }
    // #@@}

    // #@@range/instance_members{
    private String sourceName;  //源文件名字
//    private LibraryLoader loader;
    private ErrorHandler errorHandler;
    //private Set<String> knownTypedefs;
    // #@@}

    // #@@range/ctor1{
    public Parser(Reader s, String name,
                   ErrorHandler errorHandler) {
        this(s, name, errorHandler, false);
    }
    // #@@}

    // #@@range/ctor2{
    // Parser类的构造函数
    public Parser(Reader s, String name,
                  ErrorHandler errorHandler, boolean debug) {
        this(s);
        this.sourceName = name; //源程序的文件名
//        this.loader = loader;   //用import关键字读入 import文件的加载器
        this.errorHandler = errorHandler;   //处理错误或警告的对象
        //this.knownTypedefs = new HashSet<String>(); //保存用typedef定义的类型名称
        //当debug为true的时候，通过enable_tracing方法来调用javaCC的跟踪(trace)功能
        if (debug) {
            enable_tracing();
        }
        else {
            disable_tracing();
        }
    }
    // #@@}

    // #@@range/parse{
    // 解析器的启动
    public AST parse() throws SyntaxException {
        try {
            //调用和需要解析的非终端符号同名的方法开始解析处理
            return compilation_unit();
        }
        //发生扫描错误
        catch (TokenMgrError err) {
            throw new SyntaxException(err.getMessage());
        }
        //发生解析错误
        catch (ParseException ex) {
            throw new SyntaxException(ex.getMessage());
        }
        //发生解析错误，javaCC内部使用的异常
        catch (LookaheadSuccess err) {
            throw new SyntaxException("syntax error");
        }
    }
    // #@@}

    public Declarations parseDecls() throws SyntaxException {
        try {
            return declaration_file();
        }
        catch (TokenMgrError ex) {
            throw new SyntaxException(ex.getMessage());
        }
        catch (ParseException ex) {
            throw new SyntaxException(ex.getMessage());
        }
    }

   /*private void addKnownTypedefs(List<TypedefNode> typedefs) {
        for (TypedefNode n : typedefs) {
            addType(n.name());
        }
    }*/

   /*private void addType(String name) {
        knownTypedefs.add(name);
    }*/

    /*private boolean isType(String name) {
        return knownTypedefs.contains(name);
    }*/

    // #@@range/newReader{
    private IntegerLiteralNode integerNode(Location loc, String image) {
        long i = integerValue(image);
        if (image.endsWith("UL")) {
            return new IntegerLiteralNode(loc, IntegerTypeRef.ulongRef(), i);
        }
        else if (image.endsWith("L")) {
            return new IntegerLiteralNode(loc, IntegerTypeRef.longRef(), i);
        }
        else if (image.endsWith("U")) {
            return new IntegerLiteralNode(loc, IntegerTypeRef.uintRef(), i);
        }
        else {
            return new IntegerLiteralNode(loc, IntegerTypeRef.intRef(), i);
        }
    }
    // #@@}

    // #@@range/integerValue{
    private long integerValue(String image) {
        String s = image.replaceFirst("[UL]+", "");
        if (s.startsWith("0x") || s.startsWith("0X")) {
            return Long.parseLong(s.substring(2), 16);
        }
        else if (s.startsWith("0") && !s.equals("0")) {
            return Long.parseLong(s.substring(1), 8);
        }
        else {
            return Long.parseLong(s, 10);
        }
    }
    // #@@}

    // #@@range/characterCode{
    private long characterCode(String image) throws ParseException {
        String s = stringValue(image);
        if (s.length() != 1) {
            throw new Error("must not happen: character length > 1");
        }
        return (long)s.charAt(0);
    }
    // #@@}

    // #@@range/stringValue{
    private String stringValue(String _image) throws ParseException {
        int pos = 0;
        int idx;
        StringBuffer buf = new StringBuffer();
        String image = _image.substring(1, _image.length() - 1);

        while ((idx = image.indexOf("\\", pos)) >= 0) {
            buf.append(image.substring(pos, idx));
            if (image.length() >= idx + 4
                    && Character.isDigit(image.charAt(idx+1))
                    && Character.isDigit(image.charAt(idx+2))
                    && Character.isDigit(image.charAt(idx+3))) {
                buf.append(unescapeOctal(image.substring(idx+1, idx+4)));
                pos = idx + 4;
            }
            else {
                buf.append(unescapeSeq(image.charAt(idx+1)));
                pos = idx + 2;
            }
        }
        if (pos < image.length()) {
            buf.append(image.substring(pos, image.length()));
        }
        return buf.toString();
    }
    // #@@}

    private TypeRef size_t() {
        return IntegerTypeRef.ulongRef();
    }

    // #@@range/unescapeOctal{
    private static final int charMax = 255;

    private char unescapeOctal(String digits) throws ParseException {
        int i = Integer.parseInt(digits, 8);
        if (i > charMax) {
            throw new ParseException(
                "octal character sequence too big: \\" + digits);
        }
        return (char)i;
    }
    // #@@}

    // #@@range/unescapeSeq{
    private static final char bell = 7;
    private static final char backspace = 8;
    private static final char escape = 27;
    private static final char vt = 11;

    private char unescapeSeq(char c) throws ParseException {
        switch (c) {
        case '0': return '\0';
        case '"': return '"';
        case '\'': return '\'';
        case 'a': return bell;
        case 'b': return backspace;
        case 'e': return escape;
        case 'f': return '\f';
        case 'n': return '\n';
        case 'r': return '\r';
        case 't': return '\t';
        case 'v': return vt;
        default:
            throw new ParseException("unknown escape sequence: \"\\" + c);
        }
    }
    // #@@}

    // #@@range/location{
    protected Location location(Token t) {
        return new Location(sourceName, t);
    }
    // #@@}
}
PARSER_END(Parser)

/*
 * Lexical Rules
 */

// linear-white-spaces
// 跳过空白符
// #@@range/lex_spaces{
SPECIAL_TOKEN: { <SPACES: ([" ", "\t", "\n", "\r", "\f"])+> }
// #@@}

// block comment
// #@@range/lex_block_comment{
// 将SKIP换为MORE,在块注释的中途遇到文件结尾时就可以正确提示错误了。
MORE: { <"/*"> : IN_BLOCK_COMMENT } //匹配后迁移到IN_BLOCK_COMMENT状态
//只有处于IN_BLOCK_COMMENT状态，下面两个规则才有效
//而其他规则 在这个状态下将变得无效
<IN_BLOCK_COMMENT> MORE: { <~[]> }  //匹配任意一个字符
<IN_BLOCK_COMMENT> SPECIAL_TOKEN: { <BLOCK_COMMENT: "*/"> : DEFAULT }   //匹配*/的话，就回到最初的状态
// #@@}

// line comment
// 跳过行注释
// #@@range/lex_line_comment{
SPECIAL_TOKEN: {
    <LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>
}
// #@@}

// reserved words
// 扫描关键字
// #@@range/lex_reswords{
TOKEN: {
      <VOID     : "void">
    | <CHAR     : "char">
    | <SHORT    : "short">
    | <INT      : "int">
    | <LONG     : "long">
//    | <FLOAT    : "float">  //+
//    | <DOUBLE   : "double"> //+
    | <STRUCT   : "struct">
//    | <UNION    : "union">
    | <ENUM     : "enum">
    | <STATIC   : "static">
//    | <EXTERN   : "extern">
    | <CONST    : "const">
    | <SIGNED   : "signed">
    | <UNSIGNED : "unsigned">
    | <IF       : "if">
    | <ELSE     : "else">
//    | <SWITCH   : "switch">
//    | <CASE     : "case">
    | <DEFAULT_ : "default">
    | <WHILE    : "while">
    | <DO       : "do">
    | <FOR      : "for">
    | <RETURN   : "return">
    | <BREAK    : "break">
    | <CONTINUE : "continue">
//    | <GOTO     : "goto">
//    | <TYPEDEF  : "typedef">
//    | <IMPORT   : "#include">
    | <SIZEOF   : "sizeof">
}
// #@@}

// identifier
// #@@range/lex_ident{
// 扫描标识符
// 以字母或下划线开头
// 必须写在关键字后面
TOKEN: {
    <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}
// #@@}

// integer literals
// 整数
// #@@range/lex_integer{
TOKEN: {
    <INTEGER: ["1"-"9"] (["0"-"9"])* ("U")? ("L")?
            | "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+ ("U")? ("L")?
            | "0" (["0"-"7"])* ("U")? ("L")?
            >
}
// #@@}
// 实数
TOKEN: {
    <REAL_NUMBER: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
    |  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
}

// character literal
// 扫描字符字面值
// #@@range/lex_char{
MORE: { <"'"> : IN_CHARACTER }                         // rule1
<IN_CHARACTER> MORE: {
//CHARACTER_TERM状态表示：下一个符号只接受终结符
      <~["'", "\\", "\n", "\r"]> : CHARACTER_TERM      // rule2
    | <"\\" (["0"-"7"]){3}>      : CHARACTER_TERM      // rule3
    | <"\\" ~[]>                 : CHARACTER_TERM      // rule4
}
<CHARACTER_TERM> TOKEN: { <CHARACTER: "'"> : DEFAULT } // rule5 下一个符号只接受终结符
// #@@}

// string literal
// 扫描字符串字面值
// #@@range/lex_string{
// 扫描到"后，转移到IN_STRING状态
MORE: { <"\""> : IN_STRING }                           // rule1
<IN_STRING> MORE: {
      <(~["\"", "\\", "\n", "\r"])+>                   // rule2
    | <"\\" (["0"-"7"]){3}>                            // rule3
    | <"\\" ~[]>                                       // rule4
}
//直到再遇到"，回到原状态
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }        // rule5
// #@@}

/*
 *  Grammar
 */

// #@@range/compilation_unit{
// 表示1个文件整体的非终端符号
AST compilation_unit():
{
    Token t;
    Declarations  decls;
}
{
        {
            t = getToken(1);
        }
    //开头是数个import声明(import_stmts),之后排列的是函数或类型定义(top_defs)
    //<EOF>是表示文件末尾的终端符号。在像compilation_unit()这种表示需要分析的对象整体的符号最后，要写上<EOF>
        decls=top_defs() <EOF>
        {
            return new AST(location(t), decls);
        }
}
// #@@}

// #@@range/declaration_file{
Declarations declaration_file():
{
    Declarations  decls = new Declarations();
//    UndefinedFunction funcdecl;
//    UndefinedVariable vardecl;
    Constant defconst;
    StructNode defstruct;
//    UnionNode defunion;
//    TypedefNode typedef;
}
{
//    impdecls=import_stmts()
//        {
//            decls.add(impdecls);
//        }
/*    ( LOOKAHEAD(<EXTERN> typeref() <IDENTIFIER> "(")
      funcdecl=funcdecl()   { decls.addFuncdecl(funcdecl); }
    | vardecl=vardecl()     { decls.addVardecl(vardecl); }
    | */
    (defconst=defconst()   { decls.addConstant(defconst); }
    | defstruct=defstruct() { decls.addDefstruct(defstruct); }
//    | defunion=defunion()   { decls.addDefunion(defunion); }
   // | typedef=typedef()     { decls.addTypedef(typedef); }
    )*
    <EOF>
        {
            return decls;
        }
}
// #@@}

// #@@range/import_stmts{
// import声明的规则
/*Declarations import_stmts():
{
    String libid;
    Declarations impdecls = new Declarations();
}
{
    //import声明的列表，含0个或多个import_stmt
    (libid=import_stmt()
        {
            try {
                Declarations decls = loader.loadLibrary(libid, errorHandler);
                if (decls != null) {
                    impdecls.add(decls);
                    //addKnownTypedefs(decls.typedefs());
                }
            }
            catch (CompileException ex) {
                throw new ParseException(ex.getMessage());
            }
        }
    )*
        {
            return impdecls;
        }
}*/
// #@@}

// #@@range/import_stmt{
// import声明
/*String import_stmt():
{
    StringBuffer buf = new StringBuffer();
    String n;
}
{
    //import_stmt由保留字import, name(), 0个或多个点(".")和name()的列表，以及最后的分好(";")排列而成。
    <IMPORT> n=name()   { buf.append(n); }
    ("." n=name()       { buf.append("."); buf.append(n); } )*
    ";"
        {
            return buf.toString();
        }
}*/
// #@@}

// #@@range/top_defs{
// 函数或类型定义
Declarations top_defs():
{
    Declarations decls = new Declarations();
    DefinedFunction defun;
    List<DefinedVariable> defvars;
    Constant defconst;
    StructNode defstruct;
//    UnionNode defunion;
    TypedefNode typedef;
}
{
    //为了区分defun和defvars,直到出现形参列表的括号，才可以区分
    //有括号就是函数定义
    ( LOOKAHEAD(storage() typeref() <IDENTIFIER> "(")
    // 函数定义
      defun=defun()         { decls.addDefun(defun); }
    // 为了区分defvars,defconst和defstruct，defunion
    // 因为它们开头都出现了变量类型，因此只读取1个token是无法区分的
    // 而2个的话
    // struct point p;和
    // struct point {
    //      int x;
    //      int y;
    // }
    // 也无法区分
    | LOOKAHEAD(3)
    // 变量定义
      defvars=defvars()     { decls.addDefvars(defvars); }
    // 常量定义
    | defconst=defconst()   { decls.addConstant(defconst); }
    // 结构体定义
    | defstruct=defstruct() { decls.addDefstruct(defstruct); }
    // 联合体定义
//    | defunion=defunion()   { decls.addDefunion(defunion); }
    // typedef定义
    //| typedef=typedef()     { decls.addTypedef(typedef); }
    )*
        {
            return decls;
        }
}
// #@@}

// #@@range/defvars{
// 变量定义的语法
List<DefinedVariable> defvars():
{
    List<DefinedVariable> defs = new ArrayList<DefinedVariable>();
    boolean priv;
    TypeNode type;
    String name;
    ExprNode init = null;
}
{
    // storage()是可以省略的static
    // type() 变量类型
    // name() 变量名
    // ["=" init=expr()] 可以省略的初始化表达式
    // 不支持var = {1,2,3}这样子
    // int x = 3, y;
    priv=storage() type=type() name=name() ["=" init=expr()]
        {
            defs.add(new DefinedVariable(priv, type, name, init));
            init = null;
        }
    ( "," name=name() ["=" init=expr()]
        {
            defs.add(new DefinedVariable(priv, type, name, init));
            init = null;
        }
    )* ";"
        {
            return defs;
        }
}
// #@@}

// #@@range/defconst{
Constant defconst():
{
    TypeNode type;
    String name;
    ExprNode value;
}
{
    <CONST> type=type() name=name() "=" value=expr() ";"
        {
            return new Constant(type, name, value);
        }
}
// #@@}

// #@@range/defun{
// 函数定义
DefinedFunction defun():
{
    boolean priv;
    TypeRef ret;    //typeref()在语法层面上和type()是相同的
    String n;   //函数名
    Params ps;  //形参声明
    BlockNode body; //函数本体
}
{
    // static int findMax(int x, int y, int z){}
    priv=storage() ret=typeref() n=name() "(" ps=params() ")" body=block()
        {
            TypeRef t = new FunctionTypeRef(ret, ps.parametersTypeRef());
            return new DefinedFunction(priv, new TypeNode(t), n, ps, body);
        }
}
// #@@}

// #@@range/storage{
// 可以省略的static
boolean storage():
{ Token t = null; }
{
    [t=<STATIC>] { return (t == null ? false : true); }
}
// #@@}

// #@@range/storage{
// 形参声明
// 三种形式：
// 1.无参数(形参声明为void。如getc等)
// 2.定长参数(参数的个数是相同的。如puts或fgets等)
// 3.可变长参数(参数的个数不确定。如printf等)
Params params():
{
    Token t;
    Params params;
}
{
    //表示无参数的情况
    //使用LOOKAHEAD是为了排除返回值为void类型的函数指针等
      LOOKAHEAD(<VOID> ")")
      t=<VOID>
        {
            return new Params(location(t), new ArrayList<Parameter>());
        }
    //定长参数或可变长参数
    //C语言必须有1个或1个以上的形参后才支持可变长参数
    //f(...)是不允许的，至少要f(int x, ...)
    //原因在于C语言是通过可变长参数的前一个参数的地址来取得剩余参数的
    | params=fixedparams()
            ["," "..." { params.acceptVarargs(); }]
        {
            return params;
        }
}
// #@@}

// #@@range/fixedparams{
// 定长参数
Params fixedparams():
{
    List<Parameter> params = new ArrayList<Parameter>();
    Parameter param, param1;
}
{
    param1=param() { params.add(param1); }
    // LOOKAHEAD(2)避免解析为"," "..."
    ( LOOKAHEAD(2) "," param=param() { params.add(param); } )*
        {
            return new Params(param1.location(), params);
        }
}
// #@@}

// #@@range/param{
Parameter param():
{
    TypeNode t;
    String n;
}
{
    t=type() n=name() { return new Parameter(t, n); }
}
// #@@}

// #@@range/block{
// 函数定义的本体
BlockNode block():
{
    Token t;
    List<DefinedVariable> vars;
    List<StmtNode> stmts;
}
{
    //由{}围着，以defvar_list()(临时变量定义列表)开始，接着是语句列表(stmts())
    t="{" vars=defvar_list() stmts=stmts() "}"
        {
            return new BlockNode(location(t), vars, stmts);
        }
}
// #@@}


// #@@range/defvar_list{
List<DefinedVariable> defvar_list():
{
    List<DefinedVariable> result = new ArrayList<DefinedVariable>();
    List<DefinedVariable> vars;
}
{
    ( vars=defvars() { result.addAll(vars); } )*
        {
            return result;
        }
}
// #@@}

// #@@range/defstruct{
// 结构体定义
// 定义结构体和定义该结构体类型变量必须分开
StructNode defstruct():
{
    Token t;
    String n;
    List<Slot> membs;
}
{
    t=<STRUCT> n=name() membs=member_list() ";"
        {
            return new StructNode(location(t), new StructTypeRef(n), n, membs);
        }
}
// #@@}

/*
UnionNode defunion():
{
    Token t;
    String n;
    List<Slot> membs;
}
{
    t=<UNION> n=name() membs=member_list() ";"
        {
            return new UnionNode(location(t), new UnionTypeRef(n), n, membs);
        }
}
*/

// #@@range/member_list{
// 用于表示结构体或联合体成员
// 不支持对于一个类型可以用逗号分隔定义多个成员
// eg. int x,y;
// 只能 int x;
//      int y;
List<Slot> member_list():
{
    List<Slot> membs = new ArrayList<Slot>();
    Slot s;
}
{
    //slot只包括类型和变量名
    "{" (s=slot() ";" { membs.add(s); })* "}"
        {
            return membs;
        }
}
// #@@}

// #@@range/slot{
Slot slot():
{
    TypeNode t;
    String n;
}
{
    t=type() n=name() { return new Slot(t, n); }
}
// #@@}

// #@@range/funcdecl{
/*UndefinedFunction funcdecl():
{
    TypeRef ret;
    String n;
    Params ps;
}
{
    <EXTERN> ret=typeref() n=name() "(" ps=params() ")" ";"
        {
            TypeRef t = new FunctionTypeRef(ret, ps.parametersTypeRef());
            return new UndefinedFunction(new TypeNode(t), n, ps);
        }
}*/
// #@@}

/*UndefinedVariable vardecl():
{
    TypeNode t;
    String n;
}
{
    <EXTERN> t=type() n=name() ";"
        {
            return new UndefinedVariable(t, n);
        }
}
*/
// #@@range/type{
TypeNode type():
{ TypeRef ref; }
{
    ref=typeref() { return new TypeNode(ref); }
}
// #@@}

// #@@range/typeref{
TypeRef typeref():
{
    TypeRef ref;
    Token t;
    ParamTypeRefs params;
}
{
    //在typeref_base()后添加任意数量的数组[]或指针*等符号
    ref=typeref_base()
    ( LOOKAHEAD(2)
    //不定长数组
      "[" "]"
        {
            ref = new ArrayTypeRef(ref);
        }
        //定长数组
    | "[" t=<INTEGER> "]"
        {
            ref = new ArrayTypeRef(ref, integerValue(t.image));
        }
        //指针
    | "*"
        {
            ref = new PointerTypeRef(ref);
        }
        //函数指针
        //只是将函数的形参的规则(params())中的变量名去除
    | "(" params=param_typerefs() ")"
        {
            ref = new FunctionTypeRef(ref, params);
        }
    )*
        {
            return ref;
        }
}
// #@@}

// #@@range/param_typerefs{
ParamTypeRefs param_typerefs():
{ ParamTypeRefs params; }
{
      LOOKAHEAD(<VOID> ")")
      <VOID>
        {
            return new ParamTypeRefs(new ArrayList<TypeRef>());
        }
    | params=fixedparam_typerefs()
          [ "," "..."   { params.acceptVarargs(); }]
        {
            return params;
        }
}
// #@@}

// #@@range/fixedparam_typerefs{
ParamTypeRefs fixedparam_typerefs():
{
    List<TypeRef> refs = new ArrayList<TypeRef>();
    TypeRef ref;
}
{
    ref=typeref() { refs.add(ref); }
    ( LOOKAHEAD(2) "," ref=typeref() { refs.add(ref); } )*
        {
            return new ParamTypeRefs(refs);
        }
}
// #@@}

// #@@range/typeref_base{
TypeRef typeref_base():
{
    Token t, name;
}
{
      t=<VOID>          { return new VoidTypeRef(location(t)); }
    | t=<CHAR>          { return IntegerTypeRef.charRef(location(t)); }
    | t=<SHORT>         { return IntegerTypeRef.shortRef(location(t)); }
    | t=<INT>           { return IntegerTypeRef.intRef(location(t)); }
    | t=<LONG>          { return IntegerTypeRef.longRef(location(t)); }
    | LOOKAHEAD(2) t=<UNSIGNED> <CHAR>
        { return IntegerTypeRef.ucharRef(location(t)); }
    | LOOKAHEAD(2) t=<UNSIGNED> <SHORT>
        { return IntegerTypeRef.ushortRef(location(t)); }
    | LOOKAHEAD(2) t=<UNSIGNED> <INT>
        { return IntegerTypeRef.uintRef(location(t)); }
    | t=<UNSIGNED> <LONG>
        { return IntegerTypeRef.ulongRef(location(t)); }
    | t=<STRUCT> name=<IDENTIFIER>
        { return new StructTypeRef(location(t), name.image); }
/*    | t=<UNION> name=<IDENTIFIER>
        { return new UnionTypeRef(location(t), name.image); }*/
        //如果isType(getToken(1).image)返回true，就选择最后的选项
        //getToken是javaCC提供的方法，getToken(1)会返回前项的第一个token
        //isType是cbc自行定义的函数，如果传入的参数是typedef中定义过的类型名则返回true
        //也就是说，这个LOOKAHED只有在下一个读入的<IDENTIFIER>是typedef中定义过的类型名时才会成功
        //只把在typedef中定义过的名称识别为类型名
    //| LOOKAHEAD({isType(getToken(1).image)}) name=<IDENTIFIER>
        //{ return new UserTypeRef(location(name), name.image); }
}
// #@@}

// #@@range/typedef{
//typedef语句
/*TypedefNode typedef():
{
    Token t;
    TypeRef ref;
    Token newname;
}
{
    t=<TYPEDEF> ref=typeref() newname=<IDENTIFIER> ";"
        {
            addType(newname.image);
            return new TypedefNode(location(t), ref, newname.image);
        }
}*/
// #@@}

// #@@range/stmts{
// 语句的语法
// 简单的0个或多个stmt的排列
List<StmtNode> stmts():
{
    List<StmtNode> ss = new ArrayList<StmtNode>();
    StmtNode s;
}
{
    (s=stmt() { if (s != null) ss.add(s); })*
        {
            return ss;
        }
}
// #@@}

// #@@range/stmt{
StmtNode stmt():
{
    StmtNode n = null;
    ExprNode e = null;
}
{
    ( ";"
    //labeled_stmt()表示带有goto标签的语句(例如on_error:)
    //LOOKAHEAD(2)通过读入<IDENTIFIER>和":"来和其他选项进行区分
    | LOOKAHEAD(2) n=labeled_stmt()
    //表达式后面加";"的语句
    | e=expr() ";" { n = new ExprStmtNode(e.location(), e); }
    //{}围起来的语句列表，表示多个语句
    | n=block()
    | n=if_stmt()
    | n=while_stmt()
    | n=dowhile_stmt()
    | n=for_stmt()
//    | n=switch_stmt()
    | n=break_stmt()
    | n=continue_stmt()
//    | n=goto_stmt()
    | n=return_stmt()
    )
        {
            return n;
        }
}
// #@@}

LabelNode labeled_stmt():
{
    Token t;
    StmtNode n;
}
{
    t=<IDENTIFIER> ":" n=stmt()
        {
            return new LabelNode(location(t), t.image, n);
        }
}

// #@@range/if_stmt{
// if语句
//大括号可以省
IfNode if_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode thenBody, elseBody = null;
}
{
    //LOOKAHEAD(1)为了防止空悬else的情况
    //stmt中包含了程序块block
    t=<IF> "(" cond=expr() ")" thenBody=stmt()
            [LOOKAHEAD(1) <ELSE> elseBody=stmt()]   //可以省略的else部分
        {
            return new IfNode(location(t), cond, thenBody, elseBody);
        }
}
// #@@}

// #@@range/while_stmt{
//while语句的语法
WhileNode while_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode body;
}
{
    t=<WHILE> "(" cond=expr() ")" body=stmt()
        {
            return new WhileNode(location(t), cond, body);
        }
}
// #@@}

DoWhileNode dowhile_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode body;
}
{
    t=<DO> body=stmt() <WHILE> "(" cond=expr() ")" ";"
        {
            return new DoWhileNode(location(t), body, cond);
        }
}

//for语句语法
ForNode for_stmt():
{
    Token t;
    ExprNode init = null, cond = null, incr = null;
    StmtNode body;
}
{
    t=<FOR> "(" [init=expr()] ";"
              [cond=expr()] ";"
              [incr=expr()] ")" body=stmt()
        {
            return new ForNode(location(t), init, cond, incr, body);
        }
}

/*
SwitchNode switch_stmt():
{
    Token t;
    ExprNode cond;
    List<CaseNode> bodies;
}
{
    t=<SWITCH> "(" cond=expr() ")" "{" bodies=case_clauses() "}"
        {
            return new SwitchNode(location(t), cond, bodies);
        }
}
*/

/*List<CaseNode> case_clauses():
{
    List<CaseNode> clauses = new ArrayList<CaseNode>();
    CaseNode n;
}
{
    (n=case_clause() { clauses.add(n); })*
            [n=default_clause() { clauses.add(n); }]
        {
            return clauses;
        }
}*/

/*CaseNode case_clause():
{
    List<ExprNode> values;
    BlockNode body;
}
{
    values=cases() body=case_body()
        {
            return new CaseNode(body.location(), values, body);
        }
}*/

/*List<ExprNode> cases():
{
    List<ExprNode> values = new ArrayList<ExprNode>();
    ExprNode n;
}
{
    (<CASE> n=primary() ":" { values.add(n); })+
        {
            return values;
        }
}*/

/*CaseNode default_clause():
{ BlockNode body; }
{
    <DEFAULT_> ":" body=case_body()
        {
            return new CaseNode(body.location(), new ArrayList<ExprNode>(), body);
        }
}*/

BlockNode case_body():
{
    LinkedList<StmtNode> stmts = new LinkedList<StmtNode>();
    StmtNode s;
}
{
    (s=stmt() { if (s != null) stmts.add(s); })+
        {
            // last stmt of case clause must be break stmt.
            if (! (stmts.getLast() instanceof BreakNode)) {
                throw new ParseException(
                  "missing break statement at the last of case clause");
            }
            return new BlockNode(stmts.get(0).location(),
                                 new ArrayList<DefinedVariable>(),
                                 stmts);
        }
}

/*GotoNode goto_stmt():
{ Token t, name; }
{
    t=<GOTO> name=<IDENTIFIER> ";"
        {
            return new GotoNode(location(t), name.image);
        }
}*/

// #@@range/break_stmt{
// break语句
BreakNode break_stmt():
{ Token t; }
{
    t=<BREAK> ";" { return new BreakNode(location(t)); }
}
// #@@}

ContinueNode continue_stmt():
{ Token t; }
{
    t=<CONTINUE> ";" { return new ContinueNode(location(t)); }
}

//return语句
ReturnNode return_stmt():
{
    Token t;
    ExprNode expr;
}
{
    //函数没有返回值的情况
      LOOKAHEAD(2) t=<RETURN> ";" { return new ReturnNode(location(t), null); }
    //函数有返回值的情况
    | t=<RETURN> expr=expr() ";"  { return new ReturnNode(location(t), expr); }
}

// #@@range/expr{
// term()表示不包括二元运算符在内的单位“项”的非终端符号
// C语言中，赋值的左边可以用指针表示非常复杂的表达式，因此一般“项”可以位于赋值的左边
// opassign_op 表示复合赋值运算符,如"*=", "+="
// lhs:赋值的左边
// rhs:赋值的右边
ExprNode expr():
{
    ExprNode lhs, rhs, expr;
    String op;
}
{
    //三个选项共通部分只有term()，要在term()基础上再多读一个token
      LOOKAHEAD(term() "=")
      //普通的赋值表达式
      lhs=term() "=" rhs=expr()
        {
            return new AssignNode(lhs, rhs);
        }
        //比赋值表达式优先级更高的表达式
        //数字越小，所对应的表达式的优先级越高
    | expr=expr10()
        {
            return expr;
        }
}
// #@@}

// #@@range/opassign_op{
// 复合赋值运算符
String opassign_op(): {}
{
    ( "+="  { return "+"; }
    | "-="  { return "-"; }
    | "*="  { return "*"; }
    | "/="  { return "/"; }
    | "%="  { return "%"; }
    | "&="  { return "&"; }
    | "|="  { return "|"; }
    | "^="  { return "^"; }
    | "<<=" { return "<<"; }
    | ">>=" { return ">>"; }
    )
}
// #@@}

// #@@range/expr10{
// javaCC会将1个规则转化为1个方法
// 如果规则中写有非终端符号(如expr9())，就会直接调用expr9方法。如果写的是终端符号，则直接转化为token
// expr10规则的左侧不能出现expr10自身或者以expr10开头的符号
ExprNode expr10():
{ ExprNode c, t, e; }
{
    c=expr9() ["?" t=expr() ":" e=expr10()
                    { return new CondExprNode(c, t, e); }]
        {
            return c;
        }
}
// #@@}

// #@@range/expr9{
ExprNode expr9():
{ ExprNode l, r; }
{
    l=expr8() ("||" r=expr8() { l = new BinaryOpNode(l, "||", r); })*
        {
            return l;
        }
}
// #@@}

// #@@range/expr8{
ExprNode expr8():
{ ExprNode l, r; }
{
    l=expr7() ("&&" r=expr7() { l = new BinaryOpNode(l, "&&", r); })*
        {
            return l;
        }
}
// #@@}

// #@@range/expr7{
ExprNode expr7():
{ ExprNode l, r; }
{
    l=expr6() ( ">"  r=expr6() { l = new BinaryOpNode(l, ">", r); }
              | "<"  r=expr6() { l = new BinaryOpNode(l, "<", r); }
              | ">=" r=expr6() { l = new BinaryOpNode(l, ">=", r); }
              | "<=" r=expr6() { l = new BinaryOpNode(l, "<=", r); }
              | "==" r=expr6() { l = new BinaryOpNode(l, "==", r); }
              | "!=" r=expr6() { l = new BinaryOpNode(l, "!=", r); } )*
        {
            return l;
        }
}
// #@@}

// #@@range/expr6{
ExprNode expr6():
{ ExprNode l, r; }
{
    l=expr5() ("|" r=expr5() { l = new BinaryOpNode(l, "|", r); })*
        {
            return l;
        }
}
// #@@}

// #@@range/expr5{
ExprNode expr5():
{ ExprNode l, r; }
{
    l=expr4() ("^" r=expr4() { l = new BinaryOpNode(l, "^", r); })*
        {
            return l;
        }
}
// #@@}

// #@@range/expr4{
ExprNode expr4():
{ ExprNode l, r; }
{
    l=expr3() ("&" r=expr3() { l = new BinaryOpNode(l, "&", r); })*
        {
            return l;
        }
}
// #@@}

// #@@range/expr3{
ExprNode expr3():
{ ExprNode l, r; }
{
    l=expr2() ( ">>" r=expr2() { l = new BinaryOpNode(l, ">>", r); }
              | "<<" r=expr2() { l = new BinaryOpNode(l, "<<", r); }
              )*
        {
            return l;
        }
}
// #@@}

// #@@range/expr2{
ExprNode expr2():
{ ExprNode l, r; }
{
    l=expr1() ( "+" r=expr1() { l = new BinaryOpNode(l, "+", r); }
              | "-" r=expr1() { l = new BinaryOpNode(l, "-", r); }
              )*
        {
            return l;
        }
}
// #@@}

// #@@range/expr1{
ExprNode expr1():
{ ExprNode l, r; }
{
    l=term() ( "*" r=term() { l = new BinaryOpNode(l, "*", r); }
             | "/" r=term() { l = new BinaryOpNode(l, "/", r); }
             | "%" r=term() { l = new BinaryOpNode(l, "%", r); }
             )*
        {
            return l;
        }
}
// #@@}

// #@@range/term{
// term()可以是带有类型转换运算符的term()或者unary
// term可以添加类型转换，而unary()则不能
ExprNode term():
{
    TypeNode t;
    ExprNode n;
}
{
      LOOKAHEAD("(" type())
      "(" t=type() ")" n=term()     { return new CastNode(t, n); }
    | n=unary()                     { return n; }
}
// #@@}

// #@@range/unary{
// 带有前置运算符的项的符号
ExprNode unary():
{
    ExprNode n;
    TypeNode t;
}
{
    //前置++
      "++" n=unary()    { return new PrefixOpNode("++", n); }
    //前置--
    | "--" n=unary()    { return new PrefixOpNode("--", n); }
    //一元+
    | "+" n=term()      { return new UnaryOpNode("+", n); }
    //一元-
    | "-" n=term()      { return new UnaryOpNode("-", n); }
    //逻辑非
    | "!" n=term()      { return new UnaryOpNode("!", n); }
    //按位取反
    | "~" n=term()      { return new UnaryOpNode("~", n); }
    //指针引用(间接引用)
    | "*" n=term()      { return new DereferenceNode(n); }
    //地址运算符
    | "&" n=term()      { return new AddressNode(n); }
    //sizeof(类型)
    | LOOKAHEAD(3) <SIZEOF> "(" t=type() ")"
        {
            return new SizeofTypeNode(t, size_t());
        }
    //sizeof表达式
    | <SIZEOF> n=unary()
        {
            return new SizeofExprNode(n, size_t());
        }
    | n=postfix()       { return n; }
}
// #@@}

// #@@range/postfix{
// 后置运算符规则
ExprNode postfix():
{
    ExprNode expr, idx;
    String memb;
    List<ExprNode> args;
}
{
    expr=primary()
    //后置++
    ( "++"                  { expr = new SuffixOpNode("++", expr); }
    //后置--
    | "--"                  { expr = new SuffixOpNode("--", expr); }
    //数组引用
    | "[" idx=expr() "]"    { expr = new ArefNode(expr, idx); }
    //结构体或联合体的成员的引用
    | "." memb=name()       { expr = new MemberNode(expr, memb); }
    //通过指针的结构体或联合体的成员的引用
    | "->" memb=name()      { expr = new PtrMemberNode(expr, memb); }
    //函数调用
    | "(" args=args() ")"   { expr = new FuncallNode(expr, args); }
    )*
        {
            return expr;
        }
}
// #@@}

// #@@range/name{
// 非终端符号name和<IDENTIFIER>是相同的
// 将Token对象赋给了临时变量tok，并且返回tok中image属性的值作为name()的语义值
String name():
{ Token t; }
{
    t=<IDENTIFIER> { return t.image; }
}
// #@@}

// #@@range/args{
List<ExprNode> args():
{
    List<ExprNode> args = new ArrayList<ExprNode>();
    ExprNode arg;
}
{
    [ arg=expr() { args.add(arg); }
      ("," arg=expr() { args.add(arg); })* ]
        {
            return args;
        }
}
// #@@}

// #@@range/primary{
// 字面量的规则
//非终端符号primary是数值、字符、字符串的字面量、变量以及用括号括起来的表达式中的任意一者
//这里为各个选项省对应的节点对象
//最小的单位
//除最后，一般stmt->expr->term->primary
ExprNode primary():
{
    Token t;
    ExprNode n;
}
{
      t=<INTEGER>
        {
            return integerNode(location(t), t.image);
        }
    | t=<CHARACTER>
        {
            return new IntegerLiteralNode(location(t),
                                          IntegerTypeRef.charRef(),
                                          characterCode(t.image));
        }
    | t=<STRING>
        {
            return new StringLiteralNode(location(t),
                new PointerTypeRef(IntegerTypeRef.charRef()),
                stringValue(t.image));
        }
    | t=<IDENTIFIER>
        {
            return new VariableNode(location(t), t.image);
        }
    | "(" n=expr() ")"
        {
            return n;
        }
}
// #@@}
